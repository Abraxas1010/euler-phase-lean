import HeytingLean.Complex.PhaseEigenforms
import HeytingLean.Analysis.EulerBoundary
import Mathlib.Analysis.SpecialFunctions.Complex.Arg

namespace HeytingLean
namespace Complex

/-!
# A minimal “Cl₂” ↔ `ℂ` bridge (grade 0 + bivector model)

The WIP notes mention a correspondence “`Cl(2,0) ≅ ℂ via e₁e₂ ↔ i`”.

In full generality, the real Clifford algebra `Cl(2,0)` is *not* isomorphic to `ℂ`; rather,
it contains a canonical copy of `ℂ` generated by the unit bivector `e₁e₂` (which squares to `-1`).

For the purposes of this repository’s “phase” layer, we only need the **2D subalgebra**
`a + b·(e₁e₂)`.  This module models that subalgebra as a simple structure `Cl2Rep` and proves the
expected correspondence with complex numbers.
-/

/-- A 2D "Clifford-like" carrier: scalar + bivector coefficient. -/
structure Cl2Rep where
  scalar : ℝ
  bivector : ℝ

namespace Cl2Rep

@[ext] lemma ext {x y : Cl2Rep} (h₁ : x.scalar = y.scalar) (h₂ : x.bivector = y.bivector) :
    x = y := by
  cases x
  cases y
  cases h₁
  cases h₂
  rfl

/-- Map to complex: `a + b·i`. -/
noncomputable def toComplex (x : Cl2Rep) : ℂ :=
  x.scalar + Complex.I * x.bivector

/-- Map from complex numbers. -/
noncomputable def ofComplex (z : ℂ) : Cl2Rep where
  scalar := z.re
  bivector := z.im

@[simp] theorem toComplex_ofComplex (z : ℂ) :
    (ofComplex z).toComplex = z := by
  -- `re`/`im` reconstruction.
  simp only [toComplex, ofComplex]
  apply Complex.ext <;> simp

@[simp] theorem ofComplex_toComplex (x : Cl2Rep) :
    ofComplex x.toComplex = x := by
  cases x
  simp [toComplex, ofComplex]

/-- Multiplication induced from complex multiplication. -/
noncomputable def mul (x y : Cl2Rep) : Cl2Rep :=
  ofComplex (x.toComplex * y.toComplex)

@[simp] theorem toComplex_mul (x y : Cl2Rep) :
    (x.mul y).toComplex = x.toComplex * y.toComplex := by
  simp [mul]

/-- “Rotor” predicate in the 2D model: unit norm in the associated complex number. -/
def IsRotor (x : Cl2Rep) : Prop :=
  ‖x.toComplex‖ = 1

/-- A rotor is a complex phase: it can be written as `e^{iθ}`. -/
theorem rotor_is_phase (x : Cl2Rep) (hx : IsRotor x) :
    ∃ θ : ℝ, x.toComplex = HeytingLean.Analysis.eulerBoundary θ := by
  -- Mathlib: `‖z‖ = 1 ↔ ∃ θ, exp(θ*I)=z`.
  rcases (Complex.norm_eq_one_iff x.toComplex).1 hx with ⟨θ, hθ⟩
  refine ⟨θ, ?_⟩
  -- `eulerBoundary θ = exp(I*θ) = exp(θ*I)` by commutativity.
  have : HeytingLean.Analysis.eulerBoundary θ = x.toComplex := by
    simpa [HeytingLean.Analysis.eulerBoundary, mul_comm, mul_left_comm, mul_assoc] using hθ
  exact this.symm

/-- Rotor action in the `Cl2Rep` model agrees with the `ComplexNucleus` action on `ℂ`. -/
theorem rotor_action_eq_nucleus (x : Cl2Rep) (hx : IsRotor x) (v : Cl2Rep) :
    ∃ R : ComplexNucleus, (x.mul v).toComplex = R.action v.toComplex := by
  rcases rotor_is_phase x hx with ⟨θ, hθ⟩
  refine ⟨⟨θ⟩, ?_⟩
  simp only [Cl2Rep.toComplex_mul, ComplexNucleus.action, hθ]

end Cl2Rep

/-- Bridge theorem: a rotor action on a “spinor” corresponds to a phase eigenform. -/
theorem spinor_phase_correspondence :
    ∀ (R : Cl2Rep) (ψ : Cl2Rep),
      R.IsRotor →
        ∃ (F : ℂ → ℂ) (P : PhaseEigenform F),
          P.val = ψ.toComplex ∧ P.phase = R.toComplex := by
  intro R ψ hR
  refine ⟨(fun z => R.toComplex * z), ?_⟩
  refine ⟨{ val := ψ.toComplex
            phase := R.toComplex
            phase_unit := hR
            is_eigen := rfl }, ?_⟩
  exact ⟨rfl, rfl⟩

end Complex
end HeytingLean
